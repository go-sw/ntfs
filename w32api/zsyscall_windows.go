// Code generated by 'go generate'; DO NOT EDIT.

package w32api

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modadvapi32 = windows.NewLazySystemDLL("advapi32.dll")
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")
	modntdll    = windows.NewLazySystemDLL("ntdll.dll")

	procAddUsersToEncryptedFileW           = modadvapi32.NewProc("AddUsersToEncryptedFileW")
	procCloseEncryptedFileRaw              = modadvapi32.NewProc("CloseEncryptedFileRaw")
	procDecryptFileW                       = modadvapi32.NewProc("DecryptFileW")
	procDuplicateEncryptionInfoFile        = modadvapi32.NewProc("DuplicateEncryptionInfoFile")
	procEncryptFileW                       = modadvapi32.NewProc("EncryptFileW")
	procEncryptionDisable                  = modadvapi32.NewProc("EncryptionDisable")
	procFileEncryptionStatusW              = modadvapi32.NewProc("FileEncryptionStatusW")
	procFreeEncryptionCertificateHashList  = modadvapi32.NewProc("FreeEncryptionCertificateHashList")
	procOpenEncryptedFileRawW              = modadvapi32.NewProc("OpenEncryptedFileRawW")
	procQueryRecoveryAgentsOnEncryptedFile = modadvapi32.NewProc("QueryRecoveryAgentsOnEncryptedFile")
	procQueryUsersOnEncryptedFile          = modadvapi32.NewProc("QueryUsersOnEncryptedFile")
	procReadEncryptedFileRaw               = modadvapi32.NewProc("ReadEncryptedFileRaw")
	procRemoveUsersFromEncryptedFile       = modadvapi32.NewProc("RemoveUsersFromEncryptedFile")
	procSetUserFileEncryptionKey           = modadvapi32.NewProc("SetUserFileEncryptionKey")
	procWriteEncryptedFileRaw              = modadvapi32.NewProc("WriteEncryptedFileRaw")
	procBackupRead                         = modkernel32.NewProc("BackupRead")
	procBackupSeek                         = modkernel32.NewProc("BackupSeek")
	procBackupWrite                        = modkernel32.NewProc("BackupWrite")
	procCopyFileExW                        = modkernel32.NewProc("CopyFileExW")
	procFindClose                          = modkernel32.NewProc("FindClose")
	procFindFirstStreamW                   = modkernel32.NewProc("FindFirstStreamW")
	procFindNextStreamW                    = modkernel32.NewProc("FindNextStreamW")
	procGetLongPathNameW                   = modkernel32.NewProc("GetLongPathNameW")
	procGetShortPathNameW                  = modkernel32.NewProc("GetShortPathNameW")
	procMoveFileExW                        = modkernel32.NewProc("MoveFileExW")
	procMoveFileWithProgressW              = modkernel32.NewProc("MoveFileWithProgressW")
	procSetFileShortNameW                  = modkernel32.NewProc("SetFileShortNameW")
	procNtClose                            = modntdll.NewProc("NtClose")
	procNtOpenFile                         = modntdll.NewProc("NtOpenFile")
	procNtQueryEaFile                      = modntdll.NewProc("NtQueryEaFile")
	procNtQueryInformationFile             = modntdll.NewProc("NtQueryInformationFile")
	procNtSetEaFile                        = modntdll.NewProc("NtSetEaFile")
)

func addUsersToEncryptedFile(lpFileName *uint16, pEncryptionCertificates *ENCRYPTION_CERTIFICATE_LIST) (ret error) {
	r0, _, _ := syscall.Syscall(procAddUsersToEncryptedFileW.Addr(), 2, uintptr(unsafe.Pointer(lpFileName)), uintptr(unsafe.Pointer(pEncryptionCertificates)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func CloseEncryptedFileRaw(pvContext unsafe.Pointer) {
	syscall.Syscall(procCloseEncryptedFileRaw.Addr(), 1, uintptr(pvContext), 0, 0)
	return
}

func decryptFile(lpFileName *uint16, dwReserved uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procDecryptFileW.Addr(), 2, uintptr(unsafe.Pointer(lpFileName)), uintptr(dwReserved), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func duplicateEncryptionInfoFile(srcFileName *uint16, dstFileName *uint16, creationDistribution uint32, attributes uint32, lpSecurityAttributes *windows.SecurityAttributes) (ret error) {
	r0, _, _ := syscall.Syscall6(procDuplicateEncryptionInfoFile.Addr(), 5, uintptr(unsafe.Pointer(srcFileName)), uintptr(unsafe.Pointer(dstFileName)), uintptr(creationDistribution), uintptr(attributes), uintptr(unsafe.Pointer(lpSecurityAttributes)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func encryptFile(lpFileName *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procEncryptFileW.Addr(), 1, uintptr(unsafe.Pointer(lpFileName)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func encryptionDisable(dirPath *uint16, disable bool) (err error) {
	var _p0 uint32
	if disable {
		_p0 = 1
	}
	r1, _, e1 := syscall.Syscall(procEncryptionDisable.Addr(), 2, uintptr(unsafe.Pointer(dirPath)), uintptr(_p0), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func fileEncryptionStatus(lpFileName *uint16, lpStatus *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procFileEncryptionStatusW.Addr(), 2, uintptr(unsafe.Pointer(lpFileName)), uintptr(unsafe.Pointer(lpStatus)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func FreeEncryptionCertificateHashList(pUsers *ENCRYPTION_CERTIFICATE_HASH_LIST) {
	syscall.Syscall(procFreeEncryptionCertificateHashList.Addr(), 1, uintptr(unsafe.Pointer(pUsers)), 0, 0)
	return
}

func openEncryptedFileRaw(lpFileName *uint16, ulFlags uint32, pvContext *unsafe.Pointer) (ret error) {
	r0, _, _ := syscall.Syscall(procOpenEncryptedFileRawW.Addr(), 3, uintptr(unsafe.Pointer(lpFileName)), uintptr(ulFlags), uintptr(unsafe.Pointer(pvContext)))
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func queryRecoveryAgentsOnEncryptedFile(lpFileName *uint16, pRecoveryAgents *ENCRYPTION_CERTIFICATE_HASH_LIST) (ret error) {
	r0, _, _ := syscall.Syscall(procQueryRecoveryAgentsOnEncryptedFile.Addr(), 2, uintptr(unsafe.Pointer(lpFileName)), uintptr(unsafe.Pointer(pRecoveryAgents)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func queryUsersOnEncryptedFile(lpFileName *uint16, pUsers *ENCRYPTION_CERTIFICATE_HASH_LIST) (ret error) {
	r0, _, _ := syscall.Syscall(procQueryUsersOnEncryptedFile.Addr(), 2, uintptr(unsafe.Pointer(lpFileName)), uintptr(unsafe.Pointer(pUsers)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func ReadEncryptedFileRaw(pfExportCallback uintptr, pvCallbackContext unsafe.Pointer, pvContext unsafe.Pointer) (ret error) {
	r0, _, _ := syscall.Syscall(procReadEncryptedFileRaw.Addr(), 3, uintptr(pfExportCallback), uintptr(pvCallbackContext), uintptr(pvContext))
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func removeUsersFromEncryptedFile(lpFileName *uint16, pHashes *ENCRYPTION_CERTIFICATE_HASH_LIST) (ret error) {
	r0, _, _ := syscall.Syscall(procRemoveUsersFromEncryptedFile.Addr(), 2, uintptr(unsafe.Pointer(lpFileName)), uintptr(unsafe.Pointer(pHashes)), 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func SetUserFileEncryptionKey(pEncryptionCertificate *ENCRYPTION_CERTIFICATE) (ret error) {
	r0, _, _ := syscall.Syscall(procSetUserFileEncryptionKey.Addr(), 1, uintptr(unsafe.Pointer(pEncryptionCertificate)), 0, 0)
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func WriteEncryptedFileRaw(pfImportCallback uintptr, pvCallbackContext unsafe.Pointer, pvContext unsafe.Pointer) (ret error) {
	r0, _, _ := syscall.Syscall(procWriteEncryptedFileRaw.Addr(), 3, uintptr(pfImportCallback), uintptr(pvCallbackContext), uintptr(pvContext))
	if r0 != 0 {
		ret = syscall.Errno(r0)
	}
	return
}

func backupRead(file windows.Handle, buffer *byte, numberOfBytesToRead uint32, numberOfBytesRead *uint32, abort bool, processSecurity bool, context *uintptr) (err error) {
	var _p0 uint32
	if abort {
		_p0 = 1
	}
	var _p1 uint32
	if processSecurity {
		_p1 = 1
	}
	r1, _, e1 := syscall.Syscall9(procBackupRead.Addr(), 7, uintptr(file), uintptr(unsafe.Pointer(buffer)), uintptr(numberOfBytesToRead), uintptr(unsafe.Pointer(numberOfBytesRead)), uintptr(_p0), uintptr(_p1), uintptr(unsafe.Pointer(context)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func backupSeek(file windows.Handle, lowBytesToSeek uint32, highBytesToSeek uint32, lowBytesSeeked *uint32, highBytesSeeked *uint32, context *uintptr) (err error) {
	r1, _, e1 := syscall.Syscall6(procBackupSeek.Addr(), 6, uintptr(file), uintptr(lowBytesToSeek), uintptr(highBytesToSeek), uintptr(unsafe.Pointer(lowBytesSeeked)), uintptr(unsafe.Pointer(highBytesSeeked)), uintptr(unsafe.Pointer(context)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func backupWrite(file windows.Handle, buffer *byte, numberOfBytesToRead uint32, numberOfBytesRead *uint32, abort bool, processSecurity bool, context *uintptr) (err error) {
	var _p0 uint32
	if abort {
		_p0 = 1
	}
	var _p1 uint32
	if processSecurity {
		_p1 = 1
	}
	r1, _, e1 := syscall.Syscall9(procBackupWrite.Addr(), 7, uintptr(file), uintptr(unsafe.Pointer(buffer)), uintptr(numberOfBytesToRead), uintptr(unsafe.Pointer(numberOfBytesRead)), uintptr(_p0), uintptr(_p1), uintptr(unsafe.Pointer(context)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func copyFileEx(existingFileName *uint16, newFileName *uint16, progressRoutine uintptr, data unsafe.Pointer, cancel *int32, copyFlags uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procCopyFileExW.Addr(), 6, uintptr(unsafe.Pointer(existingFileName)), uintptr(unsafe.Pointer(newFileName)), uintptr(progressRoutine), uintptr(data), uintptr(unsafe.Pointer(cancel)), uintptr(copyFlags))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func findClose(findFile windows.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procFindClose.Addr(), 1, uintptr(findFile), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func findFirstStream(fileName *uint16, infoLevel int32, findStreamData unsafe.Pointer, flags uint32) (hnd windows.Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procFindFirstStreamW.Addr(), 4, uintptr(unsafe.Pointer(fileName)), uintptr(infoLevel), uintptr(findStreamData), uintptr(flags), 0, 0)
	hnd = windows.Handle(r0)
	if hnd == windows.InvalidHandle {
		err = errnoErr(e1)
	}
	return
}

func findNextStream(findStream windows.Handle, findStreamData unsafe.Pointer) (err error) {
	r1, _, e1 := syscall.Syscall(procFindNextStreamW.Addr(), 2, uintptr(findStream), uintptr(findStreamData), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func getLongPathName(shortPath *uint16, longPath *uint16, cchBuffer uint32) (length uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetLongPathNameW.Addr(), 3, uintptr(unsafe.Pointer(shortPath)), uintptr(unsafe.Pointer(longPath)), uintptr(cchBuffer))
	length = uint32(r0)
	if length == 0 {
		err = errnoErr(e1)
	}
	return
}

func getShortPathName(longPath *uint16, shortPath *uint16, cchBuffer uint32) (length uint32, err error) {
	r0, _, e1 := syscall.Syscall(procGetShortPathNameW.Addr(), 3, uintptr(unsafe.Pointer(longPath)), uintptr(unsafe.Pointer(shortPath)), uintptr(cchBuffer))
	length = uint32(r0)
	if length == 0 {
		err = errnoErr(e1)
	}
	return
}

func moveFileEx(existingFileName *uint16, newFileName *uint16, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(unsafe.Pointer(existingFileName)), uintptr(unsafe.Pointer(newFileName)), uintptr(flags))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func moveFileWithProgress(existingFileName *uint16, newFileName *uint16, progressRoutine uintptr, data unsafe.Pointer, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procMoveFileWithProgressW.Addr(), 5, uintptr(unsafe.Pointer(existingFileName)), uintptr(unsafe.Pointer(newFileName)), uintptr(progressRoutine), uintptr(data), uintptr(flags), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func setFileShortName(file windows.Handle, shortName *uint16) (err error) {
	r1, _, e1 := syscall.Syscall(procSetFileShortNameW.Addr(), 2, uintptr(file), uintptr(unsafe.Pointer(shortName)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func ntClose(fileHandle windows.Handle) (ntstatus error) {
	r0, _, _ := syscall.Syscall(procNtClose.Addr(), 1, uintptr(fileHandle), 0, 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func ntOpenFile(fileHandle *windows.Handle, accessMask uint32, objectAttributes *windows.OBJECT_ATTRIBUTES, ioStatusBlock *windows.IO_STATUS_BLOCK, sharedAccess uint32, openOptions uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtOpenFile.Addr(), 6, uintptr(unsafe.Pointer(fileHandle)), uintptr(accessMask), uintptr(unsafe.Pointer(objectAttributes)), uintptr(unsafe.Pointer(ioStatusBlock)), uintptr(sharedAccess), uintptr(openOptions))
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func ntQueryEaFile(fileHandle windows.Handle, ioStatusBlock *windows.IO_STATUS_BLOCK, buffer unsafe.Pointer, length uint32, returnSingleEntry bool, eaList unsafe.Pointer, eaListLength uint32, eaIndex *uint32, restartScan bool) (ntstatus error) {
	var _p0 uint32
	if returnSingleEntry {
		_p0 = 1
	}
	var _p1 uint32
	if restartScan {
		_p1 = 1
	}
	r0, _, _ := syscall.Syscall9(procNtQueryEaFile.Addr(), 9, uintptr(fileHandle), uintptr(unsafe.Pointer(ioStatusBlock)), uintptr(buffer), uintptr(length), uintptr(_p0), uintptr(eaList), uintptr(eaListLength), uintptr(unsafe.Pointer(eaIndex)), uintptr(_p1))
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func ntQueryInformationFile(fileHandle windows.Handle, ioStatusBlock *windows.IO_STATUS_BLOCK, fileInformation unsafe.Pointer, length uint32, fileInformationClass int32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryInformationFile.Addr(), 5, uintptr(fileHandle), uintptr(unsafe.Pointer(ioStatusBlock)), uintptr(fileInformation), uintptr(length), uintptr(fileInformationClass), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func ntSetEaFile(fileHandle windows.Handle, ioStatusBlock *windows.IO_STATUS_BLOCK, buffer unsafe.Pointer, length uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtSetEaFile.Addr(), 4, uintptr(fileHandle), uintptr(unsafe.Pointer(ioStatusBlock)), uintptr(buffer), uintptr(length), 0, 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}
